# Works with git 2.12.1

# Configuration
local SHA1_SIZE=8

# Exported variables
unset __GIT_NAME
unset __GIT_IS_SUBMODULE

unset __GIT_BRANCH_NAME
unset __GIT_BRANCH_DETACHED
unset __GIT_CURRENT_COMMIT_SHA1
unset __GIT_REMOTE_STATUS
unset __GIT_IS_DIRTY
unset __GIT_HAS_DELETED_FILE
unset __GIT_HAS_MODIF_ADDED
unset __GIT_HAS_UNMERGED_FILES
unset __GIT_HAS_UNTRACKED_FILES
unset __GIT_HAS_SUBMODULE_DELETED

unset __SUBMODULE_ADDED
unset __SUBMODULE_DIVERGED
unset __SUBMODULE_IS_DIRTY
unset __SUBMODULE_HAS_UNTRACKED_FILES

unset __GIT_CURRENT_OPERATION
unset __GIT_NUM_STASHED

# Determinate the git directory
local git_dir="$(git rev-parse --git-dir 2> /dev/null)"

# If the command failed, then we're not in a git repository
if [ -n "$git_dir" ]
then
    # Get repository name (top folder name containing the repo)
    # We'll need the path to the top level directory of the repository anyway
    # so get the information now.
    git_top_level="$(git rev-parse --show-toplevel)"

    __GIT_NAME="$(basename $git_top_level 2> /dev/null)"

    # If the .git present at the git_top_level is a file then we're in a
    # submodule inside a repository. This is for this reason we need to get the
    # path to the git directory and the path to the top level. The git directory
    # might not be simply $git_top_level/.git
    if [ ! -d $git_top_level/.git ]
    then
        __GIT_IS_SUBMODULE=yes
    fi

    # Determinate entries and branch status
    local git_status=$(git status --porcelain=v2 --branch 2> /dev/null)

    # Output is formatted
    # # branch.oid <current commit>
    # # branch.head <HEAD REFERENCE>
    # # branch.upstream <UPSTREAM REFERENCE>
    # # branch.ab +<commits ahead> -<commits behind>
    # <MODIFICATION LIST>
    #
    # Modification list as followed:
    # For ordinary changed entries:
    #   1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>
    #
    # For renamed or copied entries
    #   2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>
    #
    # For unmerged entries
    #   u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>
    #
    # Untracked items have the following format:
    #   ? <path>
    local -a lines

    lines=(${(f)git_status})

    for line in $lines
    do
        local -a words
        words=(${=line})

        case "$words[1]" in
            \#) # Branch information start with this word.
                case "$words[2]" in
                    branch.head) # Get branch head reference name
                        __GIT_BRANCH_NAME=$words[3]
                        ;;

                    branch.oid) # Get SHA1 of the HEAD
                        local sha1=$words[3]
                        __GIT_CURRENT_COMMIT_SHA1=${sha1:0:$SHA1_SIZE}
                        ;;

                    branch.ab) # Determinate status to remote.
                        if [ $words[3] = "+0" ]
                        then
                            if [ $words[4] = "-0" ]
                            then
                                __GIT_REMOTE_STATUS='up-to-date'
                            else
                                __GIT_REMOTE_STATUS='behind'
                            fi
                        else
                            if [ $words[4] = "-0" ]
                            then
                                __GIT_REMOTE_STATUS='ahead'
                            else
                                __GIT_REMOTE_STATUS='diverged'
                            fi
                        fi
                        ;;
                esac
                ;;

            1|2)
                local XY=$words[2]
                local sub=$words[3]

                if [ $sub = "N..." ]
                then
                    # Entry isn't a submodule.
                    if [ ${XY:0:1} != "." ]
                    then
                        __GIT_HAS_MODIF_ADDED='1'
                    fi

                    case ${XY:1:1} in
                        M)
                            __GIT_IS_DIRTY='1'
                            ;;
                        D)
                            __GIT_HAS_DELETED_FILE='1'
                            ;;
                    esac

                else
                    # Entry is a submodule.
                    if [ ${XY:0:1} != "." ]
                    then
                        __SUBMODULE_ADDED='1'
                    fi

                    if [ ${XY:1:1} = "D" ]
                    then
                        __GIT_HAS_SUBMODULE_DELETED='1'
                    fi

                    if [ ${sub:1:1} = "C" ]
                    then
                        __SUBMODULE_DIVERGED='1'
                    fi

                    if [ ${sub:2:1} = "M" ]
                    then
                        __SUBMODULE_IS_DIRTY='1'
                    fi

                    if [ ${sub:3:1} = "U" ]
                    then
                        __SUBMODULE_UNTRACKED_FILES='1'
                    fi
                fi
                ;;


            u)
                __GIT_HAS_UNMERGED_FILES='1'
                ;;

            \?)
                __GIT_HAS_UNTRACKED_FILES='1'
                ;;
        esac
    done

    # Find out the number of stashed list
    __GIT_NUM_STASHED=0

    stash_file="$git_dir/logs/refs/stash"

    if [[ -e "${stash_file}" ]]
    then
        while IFS='' read -r wcline || [[ -n "$wcline" ]]
        do
            __GIT_NUM_STASHED=$((__GIT_NUM_STASHED+1))
        done < ${stash_file}
    fi

    # Find out if an operation among 'rebase', 'merge', 'cherry-pick',
    # 'bisect' and 'am' is currently in progress.
    if [ -d $git_dir/rebase-apply ]
    then
        if [ -f $git_dir/rebase-apply/rebasing ]
        then
            __GIT_CURRENT_OPERATION+=" rebase"
        else
            __GIT_CURRENT_OPERATION+=" am"
        fi

    elif [ -d $git_dir/rebase-merge ]
    then
        __GIT_CURRENT_OPERATION+=" rebase"
    fi

    if [ -f $git_dir/BISECT_START ]
    then
        __GIT_CURRENT_OPERATION+=" bisect"
    fi

    if [ -f $git_dir/MERGE_HEAD ]
    then
        __GIT_CURRENT_OPERATION+=" merge"
    fi

    if [ -f $git_dir/CHERRY_PICK_HEAD ]
    then
        __GIT_CURRENT_OPERATION+=" cherry-pick"
    fi
fi
