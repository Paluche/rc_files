# Determinate entries and branch status
local git_status=$(git status --porcelain=v2 --branch 2> /dev/null)

# Output is formatted as:
# # branch.oid <current commit>
# # branch.head <HEAD REFERENCE>
# # branch.upstream <UPSTREAM REFERENCE>
# # branch.ab +<commits ahead> -<commits behind>
# <MODIFICATION LIST>
#
# The <HEAD REFERENCE> has for value '(detached)' if you're detached from
# any reference.
#
# Modification list as followed:
# For ordinary changed entries:
#   1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>
#
# For renamed or copied entries
#   2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>
#
# For unmerged entries
#   u <XY> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>
#
# Untracked items have the following format:
#   ? <path>
#
# We want to output to be colored and reduced to:
# For lines starting with '1' with 'u'
# <XY> <sub> <path>
#
# For lines starting with '2'
# <XY> <sub> <path> -> <origpath>
#
# For lines starting with '?'
# ??     <path>
#
# <sub> is N... When not a submodule. S... when it is one.


local -a lines

lines=(${(f)git_status})

for line in $lines
do
    local -a words
    words=(${=line})
    local str=""

    case "$words[1]" in
        \#)
            continue
            ;;
        1|2|u)
            local XY=$words[2]
            local sub=$words[3]

            if [ ${XY:0:1} = "." ]
            then
                str+=" "
            else
                str+=${fg[green]}
                str+=${XY:0:1}
            fi

            if [ ${XY:1:1} = "." ]
            then
                str+=" "
            else
                str+=${fg[red]}
                str+=${XY:1:1}
            fi

            str+=" "

            if [ ${sub:0:1} = "N" ]
            then
                str+=" "
            else
                str+="${fg[red]}"
                str+="${sub:0:1}"
            fi

            if [ ${sub:1:1} = "." ]
            then
                str+=" "
            else
                str+="${fg[blue]}"
                str+="${sub:1:1}"
            fi

            if [ ${sub:2:1} = "." ]
            then
                str+=" "
            else
                str+="${fg[green]}"
                str+="${sub:2:1}"
            fi

            if [ ${sub:3:1} = "." ]
            then
                str+=" "
            else
                str+="${fg[cyan]}"
                str+="${sub:3:1}"
            fi

            str+="${fg[white]}"
            str+=" "

            if [ $words[1] = "2" ]
            then
                str+="$words[11]"
                str+=" -> "
                str+="$words[10]"
            elif [ $words[1] = "1" ]
            then
                str+="$words[9]"
            else
                str+="$words[11]"
            fi
            ;;

        \?)
            str+="${fg[cyan]}"
            str+="??      "
            str+="${fg[white]}"
            str+="$words[2]"
            ;;
    esac

    echo $str
done
